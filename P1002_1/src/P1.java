import java.util.Scanner;
public class P1 {
    public static void main(String[] args) {
        
        // 배열
        int[] scores = new int[10];  // 이 때 scores 는 int 즉, 정수가 아님에 주의
        
        // scores = 90;  // 이런건 문법 오류라는 뜻. scores 는 정수가 아니므로.

        scores[0] = 90;  // 이렇게 써야 한다. 0번째 배열에 90을 대입한다는 뜻.
        scores[5] = 88;  // 5번째 배열에 88을 대입한다는 뜻.

        System.out.println(scores[0]);
        System.out.println(scores[5]);

        // 이걸 출력시키면 90 88 나온다.

        // 만약 scores[3] 을 출력시키면 어떻게 될까. 원래 변수라면 대입하지 않은 값이므로 문법오류가 떠야 하지만 배열에서는 0이 출력된다.
        // 그 이유는 변수는 Stack 메모리에 저장되고, 이 Stack에 저장된 메모리는 스코프(중괄호, 블록) 바깥으로 나오지 않는 한
        // 초기화 되지 않으므로 문법오류가 뜨지만 heap메모리는 기본 defaalut 값을 0으로 지정해놓기 때문에 문법오류도 뜨지 않고 0이 출력됨


        // new 키워드는 heap에 생성된다. 그냥 지역변수는 stack에 쌓인다.

        // int a = 10; 같은 기본타입 변수 a는, stack 에 a = 10 이라는 실제적인 값을 저장한다.
        // int[] scores = new ~   여기에 해당하는 scores 도 = 으로 값을 대입했으니 변수다.
        // 변수인데, 참조 타입 변수다.
        // heap에 인덱스를 생성할때는 주소, 즉 번지를 지정하는데 이 번지를 scores 라는 참조타입 변수에 저장한다.

        // 따라서 heap에는 13618 이라는 주소 번지를 가진, 정수 10개를 저장하는 인덱스를 생성하고
        // 그 13618이라는 번지수를 scores라는 참조변수로 stack에 저장하는 것.




        scores[10] = 99; // 이것도 안 된다. 왜냐면 배열은 인덱스를 생성에서 값을 저장하는데 이 인덱스는 0부터 시작한다.
                         // 즉 int[10] 했으면 0번째부터 10개를 생성해서 0~9까지 생성한다는 뜻이다.

        // 배열을 쓴 다는건 곧 반복문을 사용한다는 뜻이다. int 0~9 까지 10개의 점수를 대입했으니,

        for (int i = 0 ; i < 10 ; i++) {
            System.out.println(scores[i]);
        }   // 이렇게 인덱스에 대입한 i값으로 반복을 돌릴 수 있다


        // heap 에 쌓인 메모리는 참조변수가 바뀌거나 삭제되면 더 이상 참조하는 번지가 없기 때문에
        // 삭제된다.




    }
}

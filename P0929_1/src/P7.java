public class P7 {
    public static void main(String[] args) {
        
        // 타입 미스매치 -> 프로모션, 캐스팅

        
        byte a = 10;
        int b = 20;
        boolean c = true;

        // a = c;   이건 당연히 오류.
        // c = a;   이것도 당연히 오류.

        // a = b;   이건 왜 오류일까? 타입이 달라서?
        b = a;   // 그렇다면 이건 왜 오류가 안 뜰까?

        // 숫자끼리는 타입이 다를 때, 타입 프로모션(묵시적 형 변환)을 시도한다.
        // 가령, int에 byte를 밀어 넣어도 널널하기 때문에 예외적으로 문법오류가 발생하지 않는다.
        // 반면, byte에 int는, int가 더 클 수 있기 때문에(정보의 손실이 발생할 가능성이 존재하기 때문에) 타입 캐스팅이 발생한다.
        // ex) long에는 byte short int 가 다 들어갈 수 있다.

        // 단, 위의 b같은 경우, int라 할 지라도, 개발자가 값이 byte 안에 다 처리된다는 확신이 있으면,
        // 강제적으로 캐스팅(명시적 형 변환) 할 수 있다.

        a = (byte)b;  // 이런 식으로. - 위험한 문법. 논리적으로 써도 된다고 확신이 들 때만 사용한다.
        //  따라서 이때는 b가 확실히 작아야 한다. 만약 크다면, 캐스팅을 했기 때문에 문법적 오류는 발생하지 않으나, 손실이 발생한다.



        double v1 = 10;   // 이렇게 쓰면 안 된다. double 은 실수 타입이고 10은 정수 리터럴인데 문법 오류가 발생하지 않는다.
        // 이 경우, 타입 프로모션이 발생된 것.
        // 개발할 때는 double v1 = 10.0; 이런식으로 타입과 리터럴을 맞춰야 한다.

        int v2 = 30.0;   // 이것도 타입과 리터럴이 미스매치인데 타입 프로모션이 발생되지 않고 문법오류가 발생했다. 아까와 같은 경우.

        int v2 = (int)30.0;   // 다만 이것도 이렇게 강제적으로 타입 캐스팅 가능

        v1 = v2;   // 이것도 실수가 정수보다 크기 때문에 타입 프로모션이 되었지만,
        v2 = v1;   // 이건 정수가 실수보다 크지 않기 때문에 타입 프로모션이 발생되지 않았다.
        v2 = (int)v1;    // 이런식으로 캐스팅 할 수 있지만 이렇게 사용하면 문제가 발견될 가능성이 매우 높다.


        float f1 = 10.0f;
        long f2 = 925098209L;  // 이 경우, float이 실수 4byte. long은 정수 8byte 다.

        // 따라서 float이 long에 들어갈 것 같지만, 결국 long은 정수이기 때문에 실수가 무조건 커서 

        f1 = f2;   // 이게 가능하고
        f2 = f1;   // 이게 불가능하다. 
        f2 = (long)f1;    // 이렇게 캐스팅해야한다.



        // 시스템 아웃 프린트 ln은 타입에 따라서 출력이 된다.

        int t1 = 65;
        char t2 = 65;
        char t3 = 'a';   // 얘를 숫자로 출력하려면
        
        System.out.println(t1);   // 이 경우 65가 나오지만
        System.out.println(t2);   // 이 경우 A가 나온다(A알파벳 지정 숫자값)
        System.out.println((int)t3);   // 이런식으로 캐스팅을 하면 된다.














    }

}
